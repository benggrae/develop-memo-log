-   **JPA Entity 기본생성자**

-   **_어디에 사용할까?_**

-   Java Reflection API **:** 컴파일 시점이 아닌 런타임 시점에 동적으로 클래스를 객체화 하여 분석 및 추출 해낼 수 있는 프로그래밍 기법
-   JPA는 DB 값을 객체 필드에 주입할 때 `**기본 생성자로 객체를 생성한 후**` 이러한 Reflection을 사용하여 값을 매핑

-   **_왜? private로는 생성하면 안될까?_**

-   지연로딩을 사용할 경우에는 proxy 객체를 사용
-   proxy 객체는 직접 만든 객체 class를 상속하기 때문에 public 혹은 protected 기본 생성자가 필요하다. (`**private로 생성자를 만들게 되면 파생 클래스로부터의 상속 형태가 접근 불가**`가 되어버리기 때문에 제약이 생기게 된다)
-   추가설명 (재성님) : 기술과 명세는 다르다. 실제로 jsr 338은 public 또는 protected 생성자를 가이드하지만 `하이버네이트는 default 생성자까지 지원`  한다.

-   **JPA의 시퀀스 전략은 어떻게 엔티티별로 pk의 유일성을 보장하는가?**

-   **_hi/lo 알고리즘 (이미지 참고)_**

-   hi와 JPA allocationSize (이미지 내 n값) 을 `사용한 수식을 통하여 요청한 id 리스트를 리턴`
-   `증가된 hi 값을 DB가 관리`하기 때문에 여러 엔티티가 요청하여도 중복된 데이터를 리턴하지 않음!
-   lo : 응답받은 id 리스트를 순회하며 할당된 모든 id를 사용했는지 여부를 확인
-   l**o 값이 id 리스트의 인덱스를 모두 순회했으면 다음 hi value 리턴을 요청!**

-   **느낀점**